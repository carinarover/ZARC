# -*- coding: utf-8 -*-
"""projeto_zoneamento_climático

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cmlUxvfKP6uw8p6YyK-QknjAHFlXF8HX
"""

#instalando o prophet
!pip install prophet

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from prophet import Prophet
from prophet.plot import plot_plotly, plot_components_plotly
from numpy.ma.core import mean
from sklearn.metrics import mean_squared_error, mean_absolute_error
import math
import plotly.express as px
import numpy as np
import warnings
warnings.filterwarnings('ignore')
#plt.style.use('fivethirtyeight')

#Bibliotecas para classificação

from sklearn import preprocessing
from sklearn.preprocessing import StandardScaler
from sklearn import tree
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
from yellowbrick.classifier.rocauc import roc_auc
from sklearn.metrics import plot_roc_curve

from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score,accuracy_score
from imblearn.over_sampling import SMOTE, ADASYN
from collections import Counter
from sklearn import metrics
from imblearn.under_sampling import ClusterCentroids
from yellowbrick.classifier import ROCAUC

def colabOuCode(path_drive, path_local, ncolunas=None):
    '''
    Importa o DataFrame de acordo com a plataforma usada. Retorna um DataFrame.
    path_drive: caminho do arquivo no Google Colab
    path_local: caminho do arquivo na máquina local
    ncolunas: quantidade de colunas a serem importadas na máquina local
    '''
    try:
        from google.colab import drive
        drive.mount('/content/drive')
        df = pd.read_csv(path_drive)
    except:
        if ncolunas is None: df = pd.read_csv(path_local)
        else: df = pd.read_csv(path_local, nrows=ncolunas)
    return df

jatai_precipitacao_local = 'data/precipitacao_jatai_30anos.csv'
jatai_precipitacao_drive = '/content/drive/MyDrive/data/precipitacao_jatai_30anos.csv'
jatai_precipitacao = colabOuCode(jatai_precipitacao_local, jatai_precipitacao_drive, ncolunas=None)

jatai_clima_local = 'data/jatai_clima_30anos.csv'
jatai_clima_drive = '/content/drive/MyDrive/data/jatai_clima_30anos.csv'
jatai_clima = colabOuCode(jatai_clima_local, jatai_clima_drive, ncolunas=None)

"""#PRECIPITAÇÃO

##**EDA DA PRECIPITAÇÃO**

---
"""

#removendo a coluna que não faz parte da nossa análise
jatai_precipitacao = jatai_precipitacao.drop(columns = 'Unnamed: 0')

jatai_precipitacao.info()

#jatai_precipitacao['data'] = pd.to_datetime(jatai_precipitacao['data'])

#jatai_precipitacao = jatai_precipitacao.set_index('data')

jatai_precipitacao

"""###LIMPEZA DE DADOS NULOS



---


"""

jatai_precipitacao.isnull().sum()

#aplicando o método de interpolação linear
jatai_precipitacao1 = jatai_precipitacao.interpolate(method='linear', limit_direction = 'both', axis = 0)

jatai_precipitacao1.isnull().sum()

"""###ESTATÍSTICA DESCRITIVA


---

A Estatística Descritiva é o ramo da estatística que visa sumarizar e descrever qualquer conjunto de dados. Em outras palavras, é aquela estatística que está preocupada em sintetizar os dados de maneira direta, preocupando-se menos com variações e intervalos de confiança dos dados. Exemplos de estatísticas descritivas são a média, o desvio padrão e a mediana. [fonte](https://www.fm2s.com.br/estatistica-descritiva-basica-e-centralidade/)

**DESCRIBE**


---

Nossa análise começara utilizando a função describe. Com ela conseguimos obter:


* Quantidade
*   Média
*   Desvio padrão
* Mínimo e Máximo
* Quartis

Para uma melhor visualização, iremos reamostrar nossos dados para o somatório mensal.
"""

prec_eda = jatai_precipitacao1

prec_eda['data'] = pd.to_datetime(prec_eda['data'])

prec_eda = prec_eda.set_index('data')

prec_eda = prec_eda.resample('M').sum()

prec_eda.describe()

"""Como podemos observar, temos um mínimo de 3,2mm e um máximo de 473,9mm. Isso se dá porque há meses mais chuvosos e meses mais secos. 

Como esse máximo está acima do percentil 75%, é provável que ele seja um outlier. Podemos verificar a veracidade dessa informaçao plotando um boxplot.

**BOX-PLOT**


---

Na estatística, o Boxplot, ou diagrama de caixa, é uma maneira gráfica de representar a alteração dos dados de uma variável por meio de quartis. [Fonte](https://www.escolaedti.com.br/o-que-e-um-box-plot)

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbMAAAGrCAIAAADFCu4mAAAgAElEQVR4nOy9eZxUxbn//1TVWbpnYZUBhAGGfRM3cAFBiYRgvFz3+0s01+tyjYrxm8TkxpgrStSIJOYVjXGLISIiLqjRq4hxIQygCCaiRgFZhIEIw8AMy0xP91mq6vfH0100RxhpnJme5Xm/5tU0vZyuPn3O5zz11LMwrTUQBEEQWfB8D4AgCKLFQcpIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISR0QYhnhHSgkAvu8DwNdpVo7bQRrYjtba87zst2itW1GTdDNUrXUQBABgvk5TgBvHDzocSqk5c+bcddddO3fuxP8CQFVV1R133DFnzhwcsJSyurp6xowZu3btwhcg+LsDgNb68ccff+aZZ4IgMG/Bp8IwVErhz4Svxy2YLx4EAT5iDqoWCCkjcURwzj3Pk1IyxsIwdBwHvuoMbAApJefpY08pxRg73Cu11q7r4lknhMCTsIHXtzSCIJBSBkHAGOOcb9my5eGHH25EZVdKoQzhLnJdNwxD27YbeAvnvKKiYsOGDR988IHnefhDvP322x9//HFNTQ0q3bp1626++WbHcbTWuLdx+5ZlAUAYhkEQDB48uHv37rZtp1IprbUQIpVKKaUsy8J3McYsy/J9nzEWBIE5ZszwcGstE1JG4ojgnLuuK4QIw9CcHnis5wqejYwxpRSeNg3YDpzzIAiEECgxjLFsY7Pl4ziOEAK1YP369b/+9a/79u3biMqulOKch2EohAAA3/cty2pgfyoNUoHtxDTwVxcuclxXA/iBfG/l+yXde+7dV8uFHUpd1n/gN87+5qmnjeXcYozV1Oz97LMNUuowVPX1qTVr1glhl5UNKCsb4PthPB7fsmWr1vDxx5+gzlZXV7/wwgu7d+/mnONvzTn/8MMPKysrzXdPJpONtROagpar2USLAme1rus6joOX/aMzfKSUtm2jGlqWhadNA7aDUsq2bWMHoUmSbXe0cHzfdxzH9/1ly5bNmTPnqquumjhxIspZo2wfdx2aaXitMpeuBlBKjR079p133tm48fOysrKPP/64srLynHPOqaysFILt3Vt70003FRYWCiHmPfnkrFmztNa///3vJ02adPHFF953331VVVW//OUvV61a9dFHH916662ffLLmvvvui8ViVVVVZWV9TznllHfeeaeysnLRokX33XdfUVHRW2+9NXv27I4dO+7bt+/iiy++8MILOeeO40gpUdBbIKSMxJESi8UAIJlMxuNxPOEvvfTSXDeCk6xkMuk4jmVZ5v7hdFYIgeePlFJrrZR69tlnW4ssAgAOta6ubvbs2Vrrxx577M9//jN+kUbZPtrRzzzzDGT0UQjRgPIyBugD7NChw7Bhw1auXFlaWvrBBx+ceeaZHTt2rKio8P1w06ZNxx9//I033sgY/L8b/9+qVav+7d++PXXq1Hnz5jmOs3r16unTp7uuixNkIZht23v37v3xj3/ctWvXO+/85ebNm+fOnfviiy++8sorW7duHTZs2NKlSydPnnzllVeuWrXq0Ucfveiii/D4aZQ90ESQMhJHhFlAiMfjAIA24/z583O1HJVSl156aVFR0RNPPIEiCwC+7zcgdkEQoIbiRAytV5Tplg/O/Tt27Hj99dc//PDD11133YQJE7LdrF8Txli2zuJeanj76MeIx+OnnnrqE0888d3vfnfFihU33HDDli1bAMBxrCFDhqxYseLuu++ura3ds2dPbW2t1nDuueesXr36ySefnDp16vDhQwEAF1iCQAKAbdsnn3xyLOYMHDjQdV38lRcuXKi1rqys3Lx58/e///1UKjVs2LDa2tqVK1eeeuqpR2Lb5hHyMxJHBOdcCOE4jlKqtrYWzy5cPMkJtGjQx+S6Lm5cCHG416NhgqJsVjxbiywCgGVZaPOOHTv2Bz/4wQMPPPDOO++gD6FRQEctbhAAGGN1dXUNKI7nBZynR3XmmWdalvW73/2uqKjoxBNPxPk4ADz88MPvvvvu8OHDr7jiCtd1CwsLldK1tYmqqqri4uJNmzYFgdQaHMdxXZdzjldH13V8PywqKkokEgUFBZDxgXbt2jWZTG7fvj0Wi6VSKdd1i4qKcKgt2WVMykgcEWYFmXNeXFyslEI5y3U76AvD+TguHeAE8HCvNzPE7PO/JZ9REcIwxImnEGLMmDF/+MMf3nzzzUZcm8Y5Ka5NM8a01qg7h8N17SCQaFRKKceMGfPRRx+NHj0aADjntm1LqT3PO+aYY8aNG7dz584gCKqrq4VgL730Ul1d3U9+8pOKioo333xTSiWlNEE8aLQ6jlVXV1dUVBSGIXo/GGOO45x22mn/+Mc/AKC8vLxjx47Dhg0DALxMNtZ+aHRIGYkjAhcZs/8LRxU9Y1mWUsqsqHylvH55iQat11w/N1/gyPHL2rbdvXv3GTNmNNZU2oC7CK3Ir3glgCWYkoHgYFv8+FEjLcG+fc63BAcZ+lqFlmDjzxi7e9fO//npTeVLFk+ZMvm1115dv379okULb7jh+qFDB5933tQXX3x+3749YehzDoxpKQPGNIAGAMdxUqmUGQza++eee+66desuu+yyhQsXfve73+Wc43WxsZytTQFrRUGzRNsAz4158+ahjXMU8kocNWZxxkSGmohIlFfP8xzHqa2tramp6devHwBUVVV16tQJAwmCIMArE7o10PDEC5VREpxPYCAROkPwQysqKvr27QuZRTzjZW6ZtFwPKEEQjQ66BdFYMyv+xiTXWjuOwxhzXbe0tDQMQ855SUkJvh4jriATkWqsfhNEhTqLm0VXptFfrXXv3r3xU9C/HI/HW3LUDs2mCaI9Ysw61ErM2PM8DxdGMKofJ7xoG6KpKKXEZ23bRrlMpVK4QdRBfIuJz0cfq+d5qJi+7+NrMNOmxcoikM1IEO0KFEFct8FsGeMJxcUxMxcOgiAej+PU22Q3mnk0/jcIAowTCMPQrDXjU+aNtm2jRSmlxM/FlIH87YMjgmxGgmhHmOWsVCplwh7R7jNzapwLx+NxzIPGaFMUuyAIjAiaVKhkMimEQBvTsiw0LRljuM4WBAFmdqLNCAAmEd7Ymy0QUkaCaEeYEhKxWAy1zPf9WCyGkYwmzRkA6uvrY7GYUgqzG3GabFkWzqMxGRyDruLxOMtKfq+trTUqiU5MFFYAwORFfBluPz974QggZSSIdgROYzFwCh/BGTQajOg6RBEsKChAXTOlQ9BmRDcirmibzWIlC5Q/E88ImTBYvDWrPehhjMfjR12rqRkgPyNBtDsOGZ365TtoPGYHk5pkZ3yBeX12EnR2/CmuseDLzHqLSddpyfnvZDMSBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFIGQmCIKKQMhIEQUQhZSQIgohCykgQBBGFlJEgCCIKKSNBEEQUUkaCIIgopIwEQRBRSBkJgiCikDISBEFEIWUkCIKIQspIEAQRhZSRIAgiCikjQRBEFFJGgiCIKKSMBEEQUUgZCYIgopAyEgRBRCFlJAiCiELKSBAEEYWUkSAIIgopI0EQRBRSRoIgiCikjARBEFFI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mjV8+PBzzjmnsWQRAFAN0dvIOTc+qMMdt7Ztf/TRR3v37p06darjOL7vn3322a+//vru3bt93582bVpZWZnneR999BFal401zlZHizvt8RrLGBNCXHbZZaiMzfALmSChZ555xviDGnEBMS9IAA/g5cVva9sOgPl+4MQcX4bcEkodSPRIxzPjf7lQDLjmiqmvvM11PEwrW7BkUccUYwuWLA9kqLXmXGjGdKhV1s5mjOlMfHVDed8H32ZensN4WBgWWhy81He+fY7LGAemAX04KstQVBiwcxRijesblZWVP/3pT4UQmzdvfvvtt3F5OveNHeorMOZ5Hk6BcdpufFCHBJ8tLCwcMWIE2pslJSU9e/b8/PPPhRAjR47csWPHrFmzvvjii7vvvru1H/9fhxanjBHwets88Yy4aIgTE6VUy5xHaFAADWUr66ySXhIgAPAda79wU9xirtBMaYZ2OOea87QkKgAAzVEbj0QTj04ZAYCB+sblVwFAJRw4+jQDZn+pgJjm+JRiwPUR3eY8GA2WozwVFmiWBLAA4gdq73BgWKjISO3RB3n36NFDSun7fjweR1lsrEPaGA2oYl+5ZQxdRHsQJ2e+71uWJYTgnGutHcc566yz3nrrrUQi0TwBcy2TFqeM5peWUj711FNmFa+pL18YvmBZVps5GlTmL+TcE3ZSWJrZmilgUgEAMK65pTiA0kwpzGYBrplZmxZHcAu5Jgtg5YgjVDrFcvZj5jYYDZZWIJktA5n1IA60UTAhMk8//fRDDz306aefTps2bcSIEY2z9QzGt4jz6AaOYc55LBZLpVKffvppnz595s2bN3r06M2bN0+aNCmRSGzbtq2srOzCCy8cP378z3/+8wcffLBtnAtHQYvzI2itMfLetu0gCNKJa01PKpXCOYj5uEQi0QYOiwbsB4XJIezAnYzVllsOTI7j4Rq4OuLbo/3eLQjf9/FAmjZt2rBhw+bOnet53le+68g3DgDo/AEAy7IwcLKBt/Tv379r166rV69OJpNhGN5xxx0AMHDgQMbY3XffvWbNGq31li1bksnknj17GmucrY4WZzMyxoyXxCyxNUPUDsYt4go1AIRhWFhY2KSf2GwoOGiiigahCTDMw3gY8CO7bRsIITAvRQhxww03JBIJx3EaazbtOI7JXTFROw28Hodx2WWXPf7449dcc03v3r0BoGvX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)
"""

fig = px.box(prec_eda, y="precipitacao")
fig.show()

"""Como dissemos anteriormente, esse valor de 473,9mm de acumulado de chuva mensal, é um outlier. Quando se trata de natureza, lidamos com situações atípicas, um mês com um acumulado de chuva mais alto que o comum, é uma dessas situações.

**HISTOGRAMA**


---

Um histograma é uma espécie de gráfico de barras que demonstra uma distribuição de frequências. No histograma, a base de cada uma das barras representa uma classe e a altura representa a quantidade ou frequência absoluta com que o valor de cada classe ocorre. Ao mesmo tempo, ele pode ser utilizado como um indicador de dispersão de processos. [Fonte](https://www.alura.com.br/artigos/o-que-e-um-histograma)
"""

plt.figure(figsize = (10,4))
sns.distplot(prec_eda['precipitacao'])
plt.xlabel('Acumulado de Precipitação',size=16)
plt.ylabel('Densidade',size=16)
plt.title('Distribuição do Acumulado Mensal de Precipitacão no município de Jataí - GO de 1991 até 2021',size=16);

"""###PLOTANDO A SÉRIE TEMPORAL

---


"""

import plotly.graph_objects as go
prec = prec_eda.reset_index()
fig = go.Figure([go.Scatter(x=prec['data'], y=prec['precipitacao'])])
fig.show()

"""##PREVISÃO PRECIPITAÇÃO

###MANIPULAÇÃO DE DADOS PARA A PREVISÃO


---

Como o intuito do nosso trabalho é fazer uma classificação de risco climático, utilizaremos técnicas e cálculos agronômicos (explicados mais a frente). A partir de diversas tentativas, vimos que a melhor previsão é aquela onde os outliers do dado real são excluídos e trocados por valores a partir da interpolação. E, após isso, podaremos ainda mais nossos dados com o método da amplitude.

O primeiro passo é tirar o percentil 98 dos nossos dados, que são valores muito altos.
"""

#nosso percentil 98 é esse valor. Para a precipitação diária, é um valor muito alto.
jatai_precipitacao1.precipitacao.quantile(.98)

#pegando os valores acima do percentil 98 e transformando-os em nulo
jatai_precipitacao1.precipitacao[jatai_precipitacao1.precipitacao > jatai_precipitacao1.precipitacao.quantile(.98)] = np.nan
#preenchendo os novos nulos com interpolação
jatai_precipitacao1.precipitacao = jatai_precipitacao1.precipitacao.interpolate(method='linear', limit_direction = 'both', axis = 0)

#aplicando o método do desvio 
dt_mean, dt_std = np.mean(jatai_precipitacao1['precipitacao']), np.std(jatai_precipitacao1['precipitacao'])
amplitude = jatai_precipitacao1['precipitacao'].max() - jatai_precipitacao1['precipitacao'].min()
cut_off = amplitude / 2
upper = dt_mean + cut_off
idx = np.where(jatai_precipitacao1['precipitacao'] > upper)

#plotando os valores que iremos podar (em laranja)
plt.subplots(figsize=(14,7))
plt.subplot(1,2,1)
sns.scatterplot(data = jatai_precipitacao1['precipitacao'])
sns.scatterplot(data = jatai_precipitacao1['precipitacao'].iloc[idx],label='Outliers')

#transformando os outliers em nulo e preenchendo os valores por interpolação
jatai_precipitacao1['precipitacao'].iloc[idx] = np.nan
jatai_precipitacao1['precipitacao'] = jatai_precipitacao1['precipitacao'].interpolate(method='linear', limit_direction = 'both', axis = 0)

"""##PREVISÃO PARA 2023"""

jatai_precipitacao1 = jatai_precipitacao1.set_index('data')

jatai_precipitacao1.info()

#criando a coluna ds com as datas
jatai_precipitacao1['ds'] = jatai_precipitacao1.index

#criando a coluna y com os dados de precipitacao
jatai_precipitacao1['y'] = jatai_precipitacao1['precipitacao']

#fitando o prophet
modelo_precipitacao1 = Prophet()
modelo_precipitacao1.fit(jatai_precipitacao1)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2023
future_precipitacao1 = (modelo_precipitacao1.make_future_dataframe(periods=730))
future_precipitacao1.tail()

#fazendo a previsao até a data de interesse
forecast_precipitacao1 = modelo_precipitacao1.predict(future_precipitacao1)
forecast_precipitacao2 = forecast_precipitacao1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#mostra nossa previsão
fig_precipitacao1 = modelo_precipitacao1.plot(forecast_precipitacao1)

#tendencia e sazonalidade
fig_precipitacao2 = modelo_precipitacao1.plot_components(forecast_precipitacao1)

plot_plotly(modelo_precipitacao1, forecast_precipitacao1)

#fazendo um merge para avaliarmos as métricas
merge_precipitacao1 = jatai_precipitacao1.merge(forecast_precipitacao2, on = 'ds', how = 'left')

from numpy.ma.core import mean
from sklearn.metrics import mean_squared_error, mean_absolute_error
import math

#RMSE
rmse = math.sqrt(mean_squared_error(merge_precipitacao1['y'], merge_precipitacao1['yhat']))

#MAE
mae = mean_absolute_error(merge_precipitacao1['y'], merge_precipitacao1['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_precipitacao_23 = forecast_precipitacao1[forecast_precipitacao1['ds'] > '2022-12-31']
#nossos valores preditos
previsao_precipitacao_23 = previsao_precipitacao_23[['ds', 'yhat']]
previsao_precipitacao_23.rename(columns={'ds': 'data'}, inplace = True)
previsao_precipitacao_23.rename(columns={'yhat': 'precipitacao'}, inplace = True)
previsao_precipitacao_23 = previsao_precipitacao_23.set_index('data')

previsao_precipitacao_23.resample('M').sum().plot(figsize = (10,8))
plt.title('PREVISÃO DO ACUMULADO DE CHUVA MENSAL PARA 2023 EM JATAÍ - GO');

previsao_precipitacao_23

previsao_precipitacao_23.to_csv("jatai_previsao_precipitacao_diaria.csv")

"""##PREVISÃO 2021/22"""

#pegando os dados até 2020
jatai_precipitacao2 = jatai_precipitacao1[jatai_precipitacao1.index < '01/01/2021']

jatai_precipitacao2.tail()

#fitando o prophet
modelo_precipitacao2 = Prophet()
modelo_precipitacao2.fit(jatai_precipitacao2)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2022
future_precipitacao3 = (modelo_precipitacao2.make_future_dataframe(periods=730))
future_precipitacao3.tail()

#fazendo a previsao até a data de interesse
forecast_precipitacao3 = modelo_precipitacao2.predict(future_precipitacao3)
forecast_precipitacao4 = forecast_precipitacao3[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#tendencia e sazonalidade
fig_precipitacao3 = modelo_precipitacao2.plot_components(forecast_precipitacao3)

plot_plotly(modelo_precipitacao2, forecast_precipitacao3)

#fazendo um merge para avaliarmos as métricas
merge_precipitacao2 = jatai_precipitacao2.merge(forecast_precipitacao4, on = 'ds', how = 'left')

#RMSE
rmse = math.sqrt(mean_squared_error(merge_precipitacao2 ['y'], merge_precipitacao2 ['yhat']))

#MAE
mae = mean_absolute_error(merge_precipitacao2 ['y'], merge_precipitacao2 ['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_precipitacao2223 = forecast_precipitacao3[forecast_precipitacao3['ds'] > '2020-12-31']
previsao_precipitacao2223.rename(columns={'ds': 'data'}, inplace = True)
previsao_precipitacao2223.rename(columns={'yhat': 'precipitacao'}, inplace = True)
previsao_precipitacao2223 = previsao_precipitacao2223.set_index('data')
previsao_precipitacao2223 = previsao_precipitacao2223[['precipitacao']]
previsao_precipitacao2223

previsao_precipitacao2223.to_csv("jatai_previsao_diaria_precipitacao_2021_2.csv")

previsao_precipitacao2223.resample('M').sum().plot(figsize = (10,8))
plt.title('PREVISÃO DO ACUMULADO DE CHUVA MENSAL PARA 2021 E 2022 EM JATAÍ - GO');

file_name = 'jatai_previsao_preci_2021.xlsx'
previsao_precipitacao2223.to_excel(file_name)

"""#TEMPERATURA"""

jatai_clima = jatai_clima.drop(columns = 'Unnamed: 0')

jatai_clima.isnull().sum()

#aplicando o método de interpolação linear
jatai_clima1 = jatai_clima.interpolate(method='linear', limit_direction = 'both', axis = 0)

jatai_clima1.isnull().sum()

jatai_clima1['data'] = pd.to_datetime(jatai_clima1['data'])

jatai_clima1 = jatai_clima1.set_index('data')

jatai_clima1.rename(columns = {'tempetura_max': 'temperatura_max'}, inplace = True)

"""## EDA DA TEMPERATURA MÁXIMA"""

jatai_temperatura_max = jatai_clima1[['temperatura_max']]

jatai_temperatura_max

"""###ESTATÍSTICA DESCRITIVA


---

**REAMOSTRAGEM**


---

Reamostrando os dados para a média mensal
"""

tm_eda = jatai_temperatura_max
tm_eda = tm_eda.resample('M').mean()

"""**DESCRIBE**


---
"""

tm_eda.describe()

"""Podemos ver que a menor temperatura máxima é 25 graus e a maior é 34 graus, indicando que o município não enfrenta meses com temperaturas muito baixas..

**BOX-PLOT**


---
"""

fig = px.box(tm_eda, y="temperatura_max")
fig.show()

"""No box-plot podemos perceber que temperaturas máximas abaixo de 28 graus são consideradas outiliers, corroborando com nossa afirmação de que o município não enfrente meses muito gelados.

**HISTOGRAMA**


---
"""

plt.figure(figsize = (10,4))
sns.distplot(tm_eda['temperatura_max'])
plt.xlabel('Média da temperatura máxima',size=16)
plt.ylabel('Densidade',size=16)
plt.title('Distribuição da temperatura máxima média mensal no município de Jataí - GO de 1991 até 2021',size=16);

"""###PLOTANDO A SÉRIE TEMPORAL

---

"""

tm = tm_eda.reset_index()
figtm = go.Figure([go.Scatter(x=tm['data'], y=tm['temperatura_max'])])
figtm.show()

"""##PREVISÃO TEMPERATURA MÁXIMA

###PREVISÃO PARA 2023
"""

#criando a coluna ds com as datas
jatai_temperatura_max['ds'] = jatai_temperatura_max.index
#criando a coluna y com os dados de precipitacao
jatai_temperatura_max['y'] = jatai_temperatura_max['temperatura_max']

#fitando o prophet
modelo_temperatura_max1 = Prophet()
modelo_temperatura_max1.fit(jatai_temperatura_max)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2023
future_temperatura_max1 = (modelo_temperatura_max1.make_future_dataframe(periods=760))
future_temperatura_max1.tail()

#fazendo a previsao até a data de interesse
previsao_temperatura_max1 = modelo_temperatura_max1.predict(future_temperatura_max1)
previsao_temperatura_max2 = previsao_temperatura_max1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#mostra nossa previsão
fig_temperatura_max1 = modelo_temperatura_max1.plot(previsao_temperatura_max1)

#tendencia e sazonalidade
fig_temperatura_max2 = modelo_temperatura_max1.plot_components(previsao_temperatura_max1)

plot_plotly(modelo_temperatura_max1, previsao_temperatura_max1)

#fazendo um merge para avaliarmos as métricas
merge_temperatura_max1 = jatai_temperatura_max.merge(previsao_temperatura_max2, on = 'ds', how = 'left')

#RMSE
rmse = math.sqrt(mean_squared_error(merge_temperatura_max1['y'], merge_temperatura_max1['yhat']))

#MAE
mae = mean_absolute_error(merge_temperatura_max1['y'], merge_temperatura_max1['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_temp_max23 = previsao_temperatura_max1[previsao_temperatura_max1['ds'] > '2022-12-31']
#nossos valores preditos
previsao_temp_max23 = previsao_temp_max23[['ds', 'yhat']]
previsao_temp_max23.rename(columns={'ds': 'data'}, inplace = True)
previsao_temp_max23.rename(columns={'yhat': 'temperatura_max'}, inplace = True)
previsao_temp_max23 = previsao_temp_max23.set_index('data')

previsao_temp_max23.resample('M').mean().plot(figsize = (10,8))
plt.title('PREVISÃO DA MÉDIA MENSAL DA TEMPERATURA MÁXIMA PARA 2023 EM JATAÍ - GO');

previsao_temp_max23.to_csv("jatai_previsao_diaria_temp_max_2023.csv")

"""###PREVISÃO 2021/22"""

temperatura_max2223 = jatai_temperatura_max[jatai_temperatura_max.index < '2021-01-01']

temperatura_max2223.tail()

#fitando o prophet
modelo_temperatura_max2 = Prophet()
modelo_temperatura_max2.fit(temperatura_max2223)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2022
future_temperatura_max3 = (modelo_temperatura_max2.make_future_dataframe(periods=730))
future_temperatura_max3.tail()

#fazendo a previsao até a data de interesse
previsao_temperatura_max3 = modelo_temperatura_max2.predict(future_temperatura_max3)
previsao_temperatura_max4 = previsao_temperatura_max3[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#tendencia e sazonalidade
fig_temp_max2223 = modelo_temperatura_max2.plot_components(previsao_temperatura_max3)

plot_plotly(modelo_temperatura_max2, previsao_temperatura_max3)

#fazendo um merge para avaliarmos as métricas
merge_temperatura_max2 = temperatura_max2223.merge(previsao_temperatura_max4, on = 'ds', how = 'left')

#RMSE
rmse = math.sqrt(mean_squared_error(merge_temperatura_max2['y'], merge_temperatura_max2['yhat']))

#MAE
mae = mean_absolute_error(merge_temperatura_max2['y'], merge_temperatura_max2['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_temperatura_max2223 = previsao_temperatura_max3[previsao_temperatura_max3['ds'] > '2020-12-31']
previsao_temperatura_max2223.rename(columns={'ds': 'data'}, inplace = True)
previsao_temperatura_max2223.rename(columns={'yhat': 'temperatura_max'}, inplace = True)
previsao_temperatura_max2223 = previsao_temperatura_max2223.set_index('data')
previsao_temperatura_max2223= previsao_temperatura_max2223[['temperatura_max']]

previsao_temperatura_max2223.resample('M').mean().plot(figsize = (10,8))
plt.title('DADOS PREVISTOS DA TEMPERATURA MÁXIMA MÉDIA MENSAL DE 2021 - 2022 EM JATAÍ - GO');

previsao_temperatura_max2223.to_csv("jatai_previsao_diaria_temp_max_2021_2.csv")

file_name = 'jatai_previsao_tempmax_2021.xlsx'
previsao_temperatura_max2223.to_excel(file_name)

"""##EDA DA TEMPERATURA MÍNIMA"""

#filtrando apenas a temperatura mínima
jatai_temperatura_min = jatai_clima1[['temperatura_min']]

"""###ESTATÍSTICA DESCRITIVA


---

**REAMOSTRAGEM**


---
"""

tmin = jatai_temperatura_min
tmin = tmin.resample('M').mean()

"""**DESCRIBE**


---
"""

tmin.describe()

"""A temperatura mínima em Jataí varia entre 11 a 21 graus.

**BOX-PLOT**


---
"""

fig = px.box(tmin, y="temperatura_min")
fig.show()

"""###PLOTANDO A SÉRIE TEMPORAL

---
"""

tmin = tmin.reset_index()
figtm = go.Figure([go.Scatter(x=tmin['data'], y=tmin['temperatura_min'])])
figtm.show()

"""##PREVISÃO TEMPERATURA MÍNIMA

###PREVISÃO 2023
"""

#criando a coluna ds com as datas
jatai_temperatura_min['ds'] = jatai_temperatura_min.index
#criando a coluna y com os dados de precipitacao
jatai_temperatura_min['y'] = jatai_temperatura_min['temperatura_min']

#fitando o prophet
modelo_temp_min1 = Prophet()
modelo_temp_min1.fit(jatai_temperatura_min)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2023
future_temp_min1 = (modelo_temp_min1.make_future_dataframe(periods=760))
future_temp_min1.tail()

#fazendo a previsao até a data de interesse
forecast_temp_min1 = modelo_temp_min1.predict(future_temp_min1)
forecast_temp_min2 = forecast_temp_min1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#mostra nossa previsão
img_temp_min1 = modelo_temp_min1.plot(forecast_temp_min1)

#tendencia e sazonalidade
img2_temp_min2 = modelo_temp_min1.plot_components(forecast_temp_min1)

plot_plotly(modelo_temp_min1, forecast_temp_min1)

#fazendo um merge para avaliarmos as métricas
merge_temp_min1 = jatai_temperatura_min.merge(forecast_temp_min2, on = 'ds', how = 'left')

#RMSE
rmse = math.sqrt(mean_squared_error(merge_temp_min1['y'], merge_temp_min1['yhat']))

#MAE
mae = mean_absolute_error(merge_temp_min1['y'], merge_temp_min1['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_temp_min_23 = forecast_temp_min1[forecast_temp_min1['ds'] > '2022-12-31']
#nossos valores preditos
previsao_temp_min_23  = previsao_temp_min_23 [['ds', 'yhat']]
previsao_temp_min_23.rename(columns={'ds': 'data'}, inplace = True)
previsao_temp_min_23.rename(columns={'yhat': 'temperatura_min'}, inplace = True)
previsao_temp_min_23 = previsao_temp_min_23.set_index('data')

previsao_temp_min_23

previsao_temp_min_23.resample('M').mean().plot(figsize = (10,8))
plt.title('PREVISÃO DA MÉDIA MENSAL DA TEMPERATURA MÍNIMA PARA 2023 EM JATAÍ - GO');

previsao_temp_min_23.to_csv("jatai_previsao_diaria_temp_min_2023.csv")

"""###PREVISÃO 2021/22"""

temperatura_min2223 = jatai_temperatura_min[jatai_temperatura_min.index < '2021-01-01']

temperatura_min2223.tail()

#fitando o prophet
modelo_temperatura_min2 = Prophet()
modelo_temperatura_min2.fit(temperatura_min2223)

#criando um dataframe novo com as datas até onde queremos prever, que, no caso, é dezembro de 2022
future_temperatura_min3 = (modelo_temperatura_min2.make_future_dataframe(periods=730))
future_temperatura_min3.tail()

#fazendo a previsao até a data de interesse
previsao_temperatura_min3 = modelo_temperatura_min2.predict(future_temperatura_min3)
previsao_temperatura_min4 = previsao_temperatura_min3[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

#tendencia e sazonalidade
fig_temp_min2223 = modelo_temperatura_min2.plot_components(previsao_temperatura_min3)

plot_plotly(modelo_temperatura_min2, previsao_temperatura_min3)

#fazendo um merge para avaliarmos as métricas
merge_temperatura_min2 = temperatura_min2223.merge(previsao_temperatura_min4, on = 'ds', how = 'left')

#RMSE
rmse = math.sqrt(mean_squared_error(merge_temperatura_min2['y'], merge_temperatura_min2['yhat']))

#MAE
mae = mean_absolute_error(merge_temperatura_min2['y'], merge_temperatura_min2['yhat'])
print(f'MAE = {mae}')
print(f'RMSE = {rmse}')

previsao_temperatura_min2223 = previsao_temperatura_min3[previsao_temperatura_min3['ds'] > '2020-12-31']
previsao_temperatura_min2223.rename(columns={'ds': 'data'}, inplace = True)
previsao_temperatura_min2223.rename(columns={'yhat': 'temperatura_min'}, inplace = True)
previsao_temperatura_min2223 = previsao_temperatura_min2223.set_index('data')
previsao_temperatura_min2223= previsao_temperatura_min2223[['temperatura_min']]

previsao_temperatura_min2223.resample('M').mean().plot(figsize = (10,8))
plt.title('PREVISÃO DA TEMPERATURA MÍNIMA MÉDIA MENSAL DE 2021 - 2022 EM JATAÍ - GO');

previsao_temperatura_min2223.to_csv("jatai_previsao_diaria_temp_min_2021_2.csv")

file_name = 'jatai_previsao_2021.xlsx'
previsao_temperatura_min2223.to_excel(file_name)

"""# **MODELO DE CLASSIFICAÇÃO**"""

dados = pd.read_csv('/content/drive/MyDrive/data/treino_teste_jatai_2020_completo.csv', sep = ';')

dados

"""## EDA"""

dados.info()

#Convertendo vírgula para ponto dos dados objetos, para depois transformar e float
dados['etp'] = dados['etp'].str.replace(',','.')
dados['etc'] = dados['etc'].str.replace(',','.')
dados['precipitacao'] = dados['precipitacao'].str.replace(',','.')

#Convertendo objeto para float
dados['etp'] = dados['etp'].astype(float)
dados['etc'] = dados['etc'].astype(float)
dados['precipitacao'] = dados['precipitacao'].astype(float)

#Convertendo data para datetime
dados['data'] = pd.to_datetime(dados['data'])

dados.info()

#criando coluna mês
dados['mes'] = dados['data'].dt.month

# Verificando valores ausentes. #Não há valores ausentes
dados.isnull().sum()

#Verificando a distribuição dos dados
dados.describe() # A diferença de intervalos nos valores numéricos implica necessidade de normalização/padronização

# Verificar a distribuição da variável risco. #Dados desbalanceados
print(dados.risco.value_counts())

f, ax = plt.subplots(figsize=(10, 5))
dados.risco.value_counts().plot(kind='bar', title="Transaction type", ax=ax, figsize=(10,5))
plt.show()

# Verificar a matriz de correlação entre as features
sns.set_context(font_scale=1.9)
plt.figure(figsize=(12,8))

sns.heatmap(
    dados.corr(), 
    annot=True,    
    fmt='.2f',
    cmap='coolwarm'   
)

plt.show()

"""- Decêndio está correlacionado com mês, retirar mês.

- Temperatura média está altamente correlacionada com demais temperaturas, retirar.

- Qo está correlacionado com ETP, retirar ETP porque está correlacionado com outras temperaturas e Qo porque está correlacionado com temperatura mínima.

- ETC está correlacionado com Kc, retirar ETC porque está relacionada com outras também e demanda cálculo.

- Cad está correlacionado com solo, retirar Cad pelos valores serem mais altos.
"""

#Eliminando variáveis correlacionadas ou não necessárias
dataset = dados.drop(['mes', 'temp_media', 'qo', 'cad', 'data', 'etc', 'etp' ],1)

dataset

# Verificar a matriz de correlação entre as features
sns.set_context(font_scale=1.9)
plt.figure(figsize=(12,8))

sns.heatmap(
    dataset.corr(), 
    annot=True,    
    fmt='.2f',    
    cmap='coolwarm',   
)

plt.show()

"""## PADRONIZAÇÃO DOS DADOS

Padronizar os dados para colocá-los em um intervalo de valores comum, pois podem impactar na acurácia do modelo. Como temos valores de precipitação mais altos, e até mesmo de decêndios, o modelo poderá "aprender” que esses valores maiores tem maior relevância para a previsão, mas chegará nessa conclusão sob a influência da ordem de grandeza da coluna, e não pela importância da variável em si (que no caso do decêndio, não podem ser 'pesados' pelo valor de decêndio maior).
"""

dataset.describe()

dataset.reset_index(drop= True, inplace= True)

col_names = dataset.iloc[:,:4].columns
col_names

transformar = dataset.iloc[:,:4]

transformar

col = dataset.iloc[:, 4:]
col

s_scaler = StandardScaler()
df_s = s_scaler.fit_transform(transformar)
df_s = pd.DataFrame(df_s, columns=col_names)

df_s

df_s.describe()

# Concatenando os dados normalizados
dfnormal = pd.concat([df_s, col], axis=1)

# Observa-se que agora as variáveis estão em uma faixa mais semelhante.
dfnormal.describe()

"""## TREINO E TESTE"""

#Separar dados em treino e teste
X = dfnormal.drop(columns = ['risco'])
y = dfnormal['risco']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42, stratify=y)

g = sns.countplot(y)
plt.show()

# Baseline - árvore
baseline = tree.DecisionTreeClassifier()
baseline.fit(X_train, y_train)

y_pred_baseline = baseline.predict(X_test)

cm = confusion_matrix(y_test, y_pred_baseline)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=baseline.classes_)
disp.plot(cmap='Blues')

print(classification_report(y_test, y_pred_baseline))

roc_auc(baseline, X_train, y_train, X_test=X_test, y_test=y_test, classes=['0', '1', '2'])

"""## BALANCEAMENTO"""

smo = SMOTE()
X_smo, y_smo = smo.fit_resample(X_train, y_train)
print('Resultado após o oversampling %s' % Counter(y_smo))

g = sns.countplot(y_train)
plt.title("Antes do Over Sampling")
plt.show()

g = sns.countplot(y_smo)
plt.title("Depois do Over Sampling")
plt.show()

arvore = tree.DecisionTreeClassifier()
arvore.fit(X_smo, y_smo)
y_pred = arvore.predict(X_test)

confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))

roc_auc(arvore, X_train, y_train, X_test=X_test, y_test=y_test, classes=['0', '1', '2'])

"""## MODELO DE CLASSIFICAÇÃO"""

y_df = pd.DataFrame(y_smo, columns=['risco'])

X_df = pd.DataFrame(X_smo, columns=['decenio', 'precipitacao', 'temp_max', 'temp_min', 'kc', 'fase', 'grupo', 'solo'])

y_df

X_df

newdf = pd.concat([X_df, y_df], axis=1)
newdf

"""### DECISION TREE COM DADOS DESBALANCEADOS"""

DT = tree.DecisionTreeClassifier()

DT.fit(X_train, y_train)

predictions = DT.predict(X_test)

print(DT.score(X_test, y_test))
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, DT.predict(X_test)))

roc_auc(DT, X_train, y_train, X_test=X_test, y_test=y_test, classes=['0', '1', '2']);

DT.score(X_train, y_train)

DT.score(X_test, y_test)

"""### DECISION TREE COM DADOS BALANCEADOS"""

DT2 = tree.DecisionTreeClassifier()

DT2.fit(X_df, y_df)

predictions = DT2.predict(X_test)

print(DT2.score(X_test, y_test))
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, DT2.predict(X_test)))

roc_auc(DT2, X_df, y_df, X_test=X_test, y_test=y_test, classes=['0', '1', '2']);

DT2.score(X_df, y_df)

DT2.score(X_test, y_test)

"""## DADOS PARA CLASSIFICAR

### DADOS REAIS 2021-2022
"""

reais2021 = pd.read_csv('/content/drive/MyDrive/data/jatai_2021_2022_reais.csv', sep = ';')

reais2021

#Pegar somente colunas de interesse
interesse = reais2021[['decenio', 'precipitacao', 'temp_max', 'temp_min', 'kc', 'fase', 'grupo', 'solo' ]]

interesse

# PADRONIZAR
interesse.reset_index(drop= True, inplace= True)

col_names2 = interesse.iloc[:,:4].columns
col_names2

transformar2 = interesse.iloc[:,:4]

transformar2

col2 = interesse.iloc[:, 4:]
col2

s_scaler = StandardScaler()
df_s2 = s_scaler.fit_transform(transformar2)
df_s2 = pd.DataFrame(df_s2, columns=col_names2)

df_s2

# Concatenando os dados normalizados
dfnormal2021 = pd.concat([df_s2, col2], axis=1)

dfnormal2021

"""**Aplicar árvore de classificação com dados desbalanceados.**"""

dfnormal2021['risco'] = DT.predict(dfnormal2021)

dfnormal2021

"""### DADOS PREVISTOS 2021-2022"""

dadosml21 = pd.read_csv('/content/drive/MyDrive/data/dados_preditos_2021_2022.csv', sep = ';')

dadosml21

#Pegar somente colunas de interesse
inte = dadosml21[['decenio', 'precipitacao', 'temp_max', 'temp_min', 'kc', 'fase', 'grupo', 'solo' ]]

#PADRONIZAR
inte.reset_index(drop= True, inplace= True)

col_names3 = inte.iloc[:,:4].columns
col_names3

transformar3 = inte.iloc[:,:4]

transformar3

col3 = inte.iloc[:, 4:]
col3

s_scaler = StandardScaler()
df_s3 = s_scaler.fit_transform(transformar3)
df_s3 = pd.DataFrame(df_s3, columns=col_names3)

df_s3

# Concatenando os dados normalizados
dfnormalml21 = pd.concat([df_s3, col3], axis=1)

dfnormalml21

"""**Aplicar árvore de classificação com dados desbalanceados.**"""

dfnormalml21['risco'] = DT.predict(dfnormalml21)

dfnormalml21